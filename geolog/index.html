<!DOCTYPE html>
<html>
<head>
<title>GeoLog</title>

<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
  crossorigin=""
/>
<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin="">
</script>

<style>
body {
    margin: 0;
}
html, body {
    height: 100%;
}

#map {
    height: 100%;
}

.blip-icon div {
    /* if we scale the icon itself, the blip wanders around */
    display: inline-block;
    width: 2px;
    height: 2px;
    clip-path: circle(50%);
    transition: all {{.BlipLifeTime}}ms ease-in;
}
</style>

</head>
<body>

<div id="map"></div>

<script>
(() => {

// initialize with GO template variables
const darkMode = {{if .DarkMode}}true{{ else }}false{{ end }};

const pingIntervalTime = 30 * 1000;

function hslToRgb(h, s, l){
    let r, g, b;

    if(s == 0){
        r = g = b = l;
    }else{
        var hue2rgb = function hue2rgb(p, q, t){
            if(t < 0) t += 1;
            if(t > 1) t -= 1;
            if(t < 1/6) return p + (q - p) * 6 * t;
            if(t < 1/2) return q;
            if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        }

        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }

    return [r * 255, g * 255, b * 255];
}

let map = L.map('map', {zoomControl: false}).fitBounds([
    [20, -84],
    [30, 160]
]);

let luminosity;
if(darkMode) {
    var Stadia_AlidadeSmoothDark = L.tileLayer('https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}{r}.{ext}', {
        minZoom: 0,
        maxZoom: 20,
        ext: 'png'
    }).addTo(map);

    luminosity = 0.6;

} else {
    var OpenStreetMap_Mapnik = L.tileLayer('//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
    }).addTo(map)

    luminosity = 0.4;
}

const mapWidth = map.getSize().x;
const strokeWidth = mapWidth / 300;
const maxRadius = mapWidth / 15;
const loc = window.location;

map.attributionControl.setPrefix();

let scheme;
if (loc.protocol === 'https:') {
    scheme = 'wss:';
} else {
    scheme = 'ws:';
}

let ws;
let lastPingTimestamp = Date.now();
let pingInterval;
let reconnecting;

function registerWebsocketHandlers(ws) {
    ws.onmessage = function(event) {
        // check if message is a ping
        if(event.data.startsWith('ping')) {
            lastPingTimestamp = Date.now();
            return;
        }

        // else parse the lat and long and render the circle
        let latLang  = JSON.parse(event.data).slice(-2);
        renderCircle(latLang);
    };

    ws.onclose = function(event) {
        console.info('Socket is closed. Reconnecting in 1 second');

        if(reconnecting) return;
        reconnecting = true;

        // fast reconnect
        setTimeout(() => {
            clearInterval(pingInterval);
            connect();
            reconnecting = false;
        }, 1000);
    };

    ws.onerror = function(err) {
        console.error(`Socket error: ${err.message}, Closing socket`);
        ws.close();
    };

    ws.onopen = function() {
        console.info('Socket connected');
    };
}

// connect to the websocket
function connect() {
    console.info('Connecting to websocket');
    ws = new WebSocket(`${scheme}//${loc.host}/ws`);

    registerWebsocketHandlers(ws);

    // periodically check if we have received a ping in the last n seconds
    pingInterval = setInterval(function() {
        if (Date.now() - lastPingTimestamp > pingIntervalTime) {
            let seconds = pingInterval / 1000;
            console.info(`No ping received for more than ${seconds} seconds!`);
            lastPingTimestamp = Date.now();
            connect();
        }
    }, pingIntervalTime / 2);
}

// render the blips on the map
let counter = 0;
function renderCircle(latLon) {
    counter++;

    // generate color with random hue
    let color = hslToRgb(Math.random(), 1.0, luminosity);
    let cssColor = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;

    let iconId = `icon-${counter}`;

    let icon = L.divIcon({
        className: `blip-icon ${iconId}`,
        html: '<div></div>',
    });

    let marker = L.marker(latLon, {
        icon: icon,
    });

    marker.on('add', function() {
        let myIcon = document.querySelector(`.${iconId} div`);
        myIcon.style.backgroundColor = cssColor;

        // size the blip relative to the map size
        let blipSize = map.getSize().x * {{.BlipSize}};

        // animate the icon
        new Promise((resolve) => {

            setTimeout(() => {
                myIcon.style.transform = `scale(${blipSize})`;
                // myIcon.style.transform = `scale(500)`;
                myIcon.style.opacity = 0;
                resolve();
            }, 100);

        }).then(() => {
            // clean up the marker after a while
            setTimeout(() => {
                marker.removeFrom(map);
            }, {{.BlipLifeTime}} * 2);
        });
    });

    marker.addTo(map);
}

// lets party!
connect();

})();
</script>
</body>
</html>
